// 3.1 this: 

// * при решении задач имеет смысл рассуждать вслух. Прежде всего это касается срезов и собеседований. Это может помочь споткнуться на неправильном решении, не  даёт повиснуть тишине (скрадывает время для собеседующего) и позволяет вступить в диалог с интервьюером - иногда он может помочь развить мысль о решении или повернуть в нужную сторону.

const obj = {
    a: 1,
    e: (function () {
        return () => {
            console.log(this.a);
        };
    })(),
};


obj.e(); // 1
obj.e.call({ a: 2 }); // 2


// В данном коде создаются следующие объекты и функции:

// obj — объект с двумя свойствами: a и e. Свойство a имеет значение 1.
// Свойство e является результатом выполнения анонимной функции, которая возвращает другую функцию. Эта возвращённая функция выводит значение свойства a.
// Когда мы вызываем obj.e(), значение this внутри функции будет ссылаться на объект obj, поэтому выводится значение 1.

// При вызове obj.e.call({ a: 2 }) мы используем метод call, чтобы явно указать значение this. В этом случае значением this будет новый объект { a: 2 }, поэтому выводится 2.

// 3.2 this:

const obj = {
    child: {
        i: 10,
        b: () => console.log(this.i, this),
        c() {
            console.log(this.i, this);
        },
    }
};

obj.child.b(); // 10 и ссылка на child.
obj.child.c(); // 10 и ссылка на child.


// В этом коде создаются следующие объекты и функции:

// obj — объект с одним свойством child.
// Свойство child является объектом со свойствами i, b и c.
// Когда мы вызываем obj.child.b(), значение this внутри функции b будет ссылаться на объект child, поэтому выводится значение 10 и ссылка на child.

// При вызове obj.child.c() значение this также будет ссылаться на объект child, и выводится значение 10 и ссылка на child.



// 3.3 this:

function foo() {
     const x = 10;
     return {
         x: 20,
         bar: () => {
             console.log(this.x);
         },
         baz: function () {
             console.log(this.x);
         }
     };
 }

 const obj1 = foo();
 obj1.bar(); // 10
 obj1.baz(); // 20


//  В данном коде создаётся функция foo, которая возвращает объект с двумя методами: bar и baz. Внутри функции foo объявляется константа x со значением 10.

// Когда мы вызываем функцию foo, она возвращает объект со свойствами x, равными 20, и двумя методами bar и baz, которые выводят значение x.

// Поскольку методы bar и baz были созданы внутри функции foo, они наследуют контекст (значение this) от своей родительской функции. В контексте функции foo переменная x имеет значение 10, которое было объявлено в начале функции.

// Таким образом, когда мы вызываем метод bar, он выводит значение переменной x, равное 10, а не 20. Метод baz также выводит значение x, но поскольку он был создан внутри функции foo, он имеет доступ к переменной x из своей области видимости, поэтому выводит значение 20.



 const obj2 = foo.call({ x: 30 });
 
 let y = obj2.bar; 
 let z = obj2.baz; 
 y();   // 30
 z();   // 30
 
 obj2.bar();    //  30
 obj2.baz();    //  30

//  В этом коде создаётся функция foo, которая возвращает объект с двумя методами: bar и baz. Внутри функции объявляется константа x со значением 10.

// Затем мы вызываем функцию foo с использованием метода call, передавая ей объект { x: 30 } в качестве контекста. Это означает, что внутри функции foo значение this будет ссылаться на этот объект. Таким образом, переменная x внутри функции будет иметь значение 30, а не 10.

// После этого мы присваиваем методы bar и baz объекта, возвращённого функцией foo, переменным y и z соответственно. Затем мы вызываем эти методы, используя переменные y и z.

// Поскольку методы bar и baz были созданы внутри функции foo, они наследуют контекст (значение this) от своей родительской функции. В контексте объекта { x: 30 }, который был передан методу call, переменная x имеет значение 30. Поэтому при вызове методов bar и baz через переменные y и z, они выводят значение 30.

// Наконец, мы напрямую вызываем методы bar и baz, используя объект obj2. Поскольку они были созданы внутри функции foo, они также выводят значение переменной x, равное 30 в контексте объекта { x: 30 }.

